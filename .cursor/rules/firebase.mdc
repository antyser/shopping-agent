---
description: 
globs: 
alwaysApply: true
---

    You are an expert in React, and Firebase Firestore, Working with Typescript to apps for chrome extension.


    ---
Code Structure
shopping-agent/
├── dist/                   # Built extension files (output)
├── functions/              # Firebase Cloud Functions (Mock API)
│   ├── index.js            # Cloud Functions entry point
│   ├── package.json        # Dependencies for functions
│   └── .eslintrc.js        # Linter config (optional)
├── src/                    # Source code for the Chrome Extension
│   ├── manifest.json       # Extension manifest
│   ├── background/         # Background service worker scripts
│   │   ├── index.js        # Main service worker entry point
│   │   ├── firebase.js     # Firebase initialization & service export
│   │   ├── auth.js         # Authentication logic handlers
│   │   ├── api.js          # External API call functions
│   │   └── eventTracker.js # Event tracking logic (building/sending events)
│   ├── content/            # Content scripts injected into pages
│   │   ├── index.js        # Main content script entry point
│   │   ├── uiInjector.js   # Logic for injecting UI elements (optional)
│   │   └── eventListeners.js # Page interaction listeners (scroll, etc.)
│   ├── shared/             # Shared utilities and constants
│   │   ├── constants.js    # Event types, storage keys, etc.
│   │   └── utils.js        # Helper functions (throttling, etc.)
│   └── assets/             # Static assets (icons, images)
│       └── icon-128.png
│       └── ...
├── .gitignore
├── package.json            # Project dependencies & build scripts
└── README.md

    Project Structure and File Naming
    - Organize by feature directories (e.g., 'services/', 'components/', 'pipes/')
    - Use environment variables for different stages (development, production)
    - Create build scripts for bundling and deployment
    - Structure Firestore collections logically (e.g., 'users/', 'spots/', 'bookings/')
    - Maintain Firebase configurations for different environments
  
  
    ## Project Structure and Organization
    - Use descriptive names for variables and functions (e.g 'getUsers', 'calculateTotalPrice').
    - Keep classes small and focused.
    - Avoid global state when possible.
    - Manage routing through a dedicated module
    - Use the latest ES6+ features and best practices for Typescript and React.
    - Centralize API calls and error handling through services
    - Manage all storage through single point of entry and retrievals. Also put storage keys at single to check and find.
    - Create dedicated Firebase services for each collection type
    - Implement Firebase error handling in a centralized service
    - Use Firebase transactions for data consistency
    - Use Firebase rules for data security
    - Use Firebase functions for serverless backend logic
    - Use Firebase storage for file uploads and downloads
    - Use Firebase authentication for user management
    - Use Firebase analytics for tracking user behavior
    - Use Firebase crash reporting for error tracking
    - Structure Firestore queries for optimal performance
    
    ## Naming Conventions
    - camelCase: functions, variables (e.g., `getUsers`, `totalPrice`)
    - kebab-case: file names (e.g., `user-service.ts`, `home-component.ts`)
    - PascalCase: classes (e.g., `UserService`)
    - Booleans: use prefixes like 'should', 'has', 'is' (e.g., `shouldLoadData`, `isLoading`).
    - UPPERCASE: constants and global variables (e.g., `API_URL`, `APP_VERSION`).
    - Firestore collections: plural nouns (e.g., `users`, `bookings`).
    - Firestore documents: descriptive IDs (e.g., `user-${uid}`, `booking-${timestamp}`).
  
    ## Dependencies and Frameworks
    - Avoid using any external frameworks or libraries unless its absolutely required.
    - Use native plugins through Ionic Native wrappers with proper fallbacks for a smooth user experience in both web and native platforms.
    - While choosing any external dependency, check for the following things:
        - Device compatibility
        - Active maintenance
        - Security
        - Documentation
        - Ease of integration and upgrade
    - Use native components for both mobile and web if available and fullfill the requirements.
    - Use official Firebase SDKs for Firestore integration.
    - Implement proper Firebase initialization and configuration.
    - Handle Firebase Authentication properly.
    - Set up appropriate Firebase Security Rules.
  
    ## UI and Styles
    - Create reusable components for complex UI.
    - Use SCSS for styling.
    - Centralize themes, colors, and fonts.
    - Implement loading states for Firebase operations.
    - Handle Firebase offline data gracefully.
    - Show appropriate error messages for Firebase operations.
    - Implement real-time UI updates with Firebase snapshots.

    ## Performance and Optimization
    -  Implement lazy loading.
    - Use pre-fetching for critical data.
    - Use caching for all the data that is needed multiple times.
    - Use global error and alert handlers.
    - Integrate any crash reporting service for the application.
    - Use a centralised alert handler to handle all the alert in the application.
    - Implement Firebase offline persistence.
    - Use Firebase query cursors for pagination.
    - Optimize Firestore reads with proper indexing.
    - Cache Firestore query results.
    - Use Firestore batch operations for bulk updates.
    - Monitor Firestore quota usage.
    
    ## Testing
    - Write comprehensive unit tests
    - Make sure to cover all the edge cases and scenarios.
    - In case of Native plugins, write mock services for the same.
    - Test Firebase integration thoroughly
    - Mock Firestore services in tests
    - Test Firebase security rules
    - Implement Firebase emulator for testing
    - Test offline functionality
    - Verify Firebase error handling

    Follow the official React and Firebase/Firestore guides for best practices.

    